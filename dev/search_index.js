var documenterSearchIndex = {"docs":
[{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"EditURL = \"@__REPO_ROOT_URL__/\"","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"Load packages.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"using Conv\nusing FocusedBlindDecon\nusing Gadfly","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"We consider an illustrative synthetic experiment with the following parameters.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"ntg=30 # number of time samples in `g`\nnr=20 # number of receivers\nnt=40*ntg # time samples in records `d`\nnts=nt # samples in `s`","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"The aim is to reconstruct the true g, i.e., gobs, that we are going to design below. This design is of particular interest e.g., in seismic inversion and room acoustics as they reveal the arrival of energy, propagated from an impulsive source, at the receivers. Here, the arrivals curve linearly and hyperbolically, depending on c and have onsets depending on bfrac. Their amplitudes are determined by afrac.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"gobs=zeros(ntg,nr) # allocate\nFBD.toy_direct_green!(gobs, c=4.0, bfrac=0.20, afrac=1.0); # add arrival 1\nFBD.toy_reflec_green!(gobs, c=1.5, bfrac=0.35, afrac=-0.6); # add arrival 2\n#plotg=(x;args...)->heatmap(x, size=(250,500), yflip=true, ylabel=\"time\", xlabel=\"channel\";args...) # define a plot recipe\n#p1=plotg(gobs, title=\"True g\")","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"The source signature s for the experiment is arbitrary: we simply use a Gaussian random signal.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"sobs=randn(nts)\n#plot(sobs, label=\"arbitrary source\", size=(1000,200))\nplot(x=1:10, y=randn(10))","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"The next task is to generate synthetic observed records dobs: first lets construct a linear operator S; then applying S on g will result in measurements d. This task can be skipped if measured dobs are already available.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"S=Conv.S(sobs, gsize=[ntg,nr], dsize=[nt,nr], slags=[nts-1,0]);\ndobs=reshape(S*vec(gobs), nt, nr);","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"We first need to allocate a parameter variable pa, where the inputs gobs and sobs are optional.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"pa=P_fbd(ntg, nt, nr, nts, dobs=dobs, gobs=gobs, sobs=sobs)","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"The we perform LSBD i.e., least-squares fitting, without regularization, of dobs to jointly optimize the arrays g and s.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"FBD.lsbd!(pa)","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"We extract g from pa and plot to notice that it doesn't match gobs.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"#p2=plotg(pa[:g], title=\"LSBD g\")","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"Instead, we perform FBD that uses the focusing functionals to regularize lsbd!.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"FBD.fbd!(pa)","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"Notice that the extract impulse responses are closer to gobs, except for a scaling factor and an overall translation in time.","category":"page"},{"location":"tut1/#","page":"Tutorial I","title":"Tutorial I","text":"#p3=plotg(pa[:g], title=\"FBD g\")\n#plot(p1,p2,p3, size=(750,500), layout=(1,3))","category":"page"},{"location":"library/#","page":"Library","title":"Library","text":"P_fbd\nFocusedBlindDecon.getindex(::P_fbd, ::Symbol)\nFocusedBlindDecon.lsbd!(::P_fbd, ::Any)\nFocusedBlindDecon.fibd!(::P_fbd, ::Any)\nFocusedBlindDecon.fpr!(::P_fbd)\nFocusedBlindDecon.fbd!(::P_fbd, ::Any)","category":"page"},{"location":"library/#FocusedBlindDecon.P_fbd","page":"Library","title":"FocusedBlindDecon.P_fbd","text":"This package defines a P_fbd type to represent the FBD model, and provides a set of methods to access its properties. In order to generate an instance of P_fbd, use the following command, where the description of the arguments  and keywords is given below.\n\npa=P_fbd(ntg, nt, nr, nts; dobs, gobs, sobs)\n\nArguments\n\nLet (ntg,nr)=size(g), (nt,nr)=size(d) and (nts,)=size(s), where\n\nntg is input dimension of the channel impulse responses g. \n\nnt is input dimension of the channel outputs d. \n\nnr is the number of receivers or channels.\n\nnts is input dimension of the source.\n\nKeywords\n\ndobs are the channel responses that will be factorized. Alternatively, the user may input the next two keywords i.e., gobs and sobs for synthetic experiments, where dobs are internally generated.\n\ngobs (optional) are the true channel impulse responses, stored in pa. \n\nsobs (optional) similarly, it is the true source.\n\n\n\n\n\n","category":"type"},{"location":"library/#Base.getindex-Tuple{P_fbd,Symbol}","page":"Library","title":"Base.getindex","text":"Let pa be in instance of the FBD model. Its properties can be easily accessed as using the following getindex calls.\n\npa[:s] returns the source, either estimated after fbd! or lsbd!, from the model.\n\npa[:sa] returns the auto-correlated source, estimated after fibd!.\n\npa[:g] returns the channel impulse responses, estimated after fbd! or lsbd!.\n\npa[:xg] returns the interferometric channel impulse responses estimated after fibd!.\n\npa[:d] returns the convolution of pa[:s] and pa[:g].\n\npa[:xd] returns the convolution of pa[:sa] and pa[:xg].\n\npa[:sobs] returns the true source, when stored.\n\npa[:gobs] returns the true impulse responses, when stored.\n\npa[:xgobs] returns the true interferometric channel impulse responses, if stored.\n\npa[:dobs] returns the measured channel outputs that fbd! or lsbd! aims to factorize.\n\npa[:xdobs] returns the measured interferometric channel outputs that fibd! aims to factorize.\n\n\n\n\n\n","category":"method"},{"location":"library/#FocusedBlindDecon.lsbd!-Tuple{P_fbd,Any}","page":"Library","title":"FocusedBlindDecon.lsbd!","text":"One can use the lsbd! method to perform LSBD over a given instance of P_fbd i.e., pa. LBSD is a least-squares fitting of d to jointly optimize the g and s, which can be accessed via  pa[:g] and pa[:s], respectively. The joint optimization is carried out using alternating minimization: in one cycle, we fix one array and optimize the other, and then fix the other  and optimize the first.  Several cycles are expected to be performed to reach convergence.\n\nlsbd!(pa)\nheatmap(pa[:g], title=\"estimated impulse responses from LSBD\")\n\n\n\n\n\n","category":"method"},{"location":"library/#FocusedBlindDecon.fibd!-Tuple{P_fbd,Any}","page":"Library","title":"FocusedBlindDecon.fibd!","text":"One can use the fibd! method to perform FIBD over a given instance of P_fbd i.e., pa. FIBD is a least-squares fitting of xd to jointly optimize the xg and sa, which can be accessed via  pa[:xg] and pa[:sa], respectively. The joint optimization is carried out using alternating minimization.\n\nfibd!(pa)\nheatmap(pa[:xg], title=\"estimated interferometric impulse responses from FIBD\")\n\n\n\n\n\n","category":"method"},{"location":"library/#FocusedBlindDecon.fpr!-Tuple{P_fbd}","page":"Library","title":"FocusedBlindDecon.fpr!","text":"After performing FIBD on a P_fbd instance pa, we can perform FPR to complete FBD. These two code blocks should be equivalent. \n\nfibd!(pa)\nfpr!(pa)\n\nfbd!(pa)\n\nThe result of FPR i.e, g can be extracted using pa[:g]. The corresponding source signature is stored in pa[:s].\n\n\n\n\n\n","category":"method"},{"location":"library/#FocusedBlindDecon.fbd!-Tuple{P_fbd,Any}","page":"Library","title":"FocusedBlindDecon.fbd!","text":"Perform FIBD and FPR to complete FBD of an instance of P_fbd i.e., pa.\n\nfbd!(pa)\nplot(pa[:g], title=\"estimated impulse responses using FBD\")\nplot(pa[:s], title=\"estimated source using FBD\")\n\n\n\n\n\n","category":"method"},{"location":"tut2/#","page":"-","title":"-","text":"EditURL = \"@__REPO_ROOT_URL__/\"","category":"page"},{"location":"#FocusedBlindDecon-1","page":"Home","title":"FocusedBlindDecon","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Geophysicists rely on seismic data to understand the Earthâ€™s subsurface. Data from seismic receivers d{T,2}(nt,nr) contains two types of information convoluted into a single signal: information about the source of the signal (source effects s{T,1}(nts)) and information about the subsurface features it passed through on its way to the receiver (path effects g{T,2}(ntg,nr)).   Conventional methods for separating out the two types of information rely on assumptions which may not be completely accurate: extracting source effects requires assumptions about the path, and extracting path effects requires assumptions about the source.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Similarly, in room acoustics, the speech signal s recorded as d at a microphone array is distorted as sound is reverberated  due to g i.e., the reflection of walls, furniture and other objects. Speech recognition and compression is simpler when the reverberated records d at the microphones are factorized into the distortions g and the clean speech signal s.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Focused Blind Deconvolution (FBD) performs the above-mentioned factorization and extracts either the  source or path information without relying on their assumptions, instead:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"it compares data d from the same source picked up by multiple receivers, and identifies similarities and differences among them;\nsimilarities among the signals can be identified as source effects s, while dissimilarities indicate path effects g.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"FocusedBlindDecon is a Julia package corresponding to the article:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Bharadwaj, Pawan, Laurent Demanet, and AimÃ© Fournier. \"Focused blind deconvolution.\" \nIEEE Transactions on Signal Processing 67.12 (2019): 3168-3180.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package uses the fast Fourier transform FFTW.jl on the zero-padded signals in order to perform multi-dimensional cross-correlations and convolutions. After installation, the package has to be initialized either to utilize either of the two packages: IterativeSolvers.jl or Optim.jl, for solving the linear systems. For example, execute one of the following commands.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using FocusedBlindDecon # start import package, also aliased as FBD\nFBD.__init__(optg=\"optim\", opts=\"optim\") # uses Optim while solving for g and s\nFBD.__init__(optg=\"iterativesolvers\", opts=\"optim\") # uses Optim while solving for s, and IterativeSolvers for g","category":"page"},{"location":"#","page":"Home","title":"Home","text":"By default, FBD.__init__() chooses the solvers from IterativeSolvers.jl for optimized performance. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The functionality of this package revolves around the mutable P_fbd type. Firstly, most of the memory necessary to perform a given optimization is allocated while creating an instance of P_fbd, denoted as pa. Then this instance is input to in-place functions (e.g., lsbd!, fbd!, fibd!)   which as per Julia convention ends with an exclamation mark, to actually perform the optimizations. Finally, the outputs of the optimizations can be easily accessed from pa e.g., pa[:s] returns the estimated source.  Details of these methods are provided in the next section.","category":"page"}]
}
